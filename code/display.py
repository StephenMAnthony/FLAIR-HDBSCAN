import numpy as np
import pandas
import torch
import matplotlib.pyplot as plt
from sklearn import metrics

from calc_miou import calc_miou
from classifier import extract_spectra

LUT_COLORS = ['#db0e9a',
              '#938e7b',
              '#f80c00',
              '#a97101',
              '#1553ae',
              '#194a26',
              '#46e483',
              '#f3a60d',
              '#660082',
              '#55ff00',
              '#fff30d',
              '#e4df7c',
              '#3de6eb',
              '#ffffff',
              '#8ab3a0',
              '#6b714f',
              '#c5dc42',
              '#9999ff',
              '#000000']


def find_channel_label(dataframe: pandas.DataFrame, channel: int) -> str:
    # Determine the column label associated with the specified channel.
    columns = dataframe.columns.values.tolist()
    n_columns = len(columns)
    if channel < 1 or channel >= n_columns:
        return f"Error: Channel must be between 1 and {n_columns - 1}!"
    else:
        return columns[channel]


def display_confusion(input_dict: dict, config: dict):
    np.set_printoptions(precision=1)

    true_classes = input_dict["true_classes"]
    predicted_classes = input_dict["predicted_classes"]

    if "model" in input_dict:
        # We have a model. Unpack variables and display a convenient string detailing the model
        if input_dict["use_hdbscan"]:
            print("Using labels autonomously generated by HDBSCAN to fit the KNN model.")
        else:
            print("Using manually annotated labels to fit the KNN model.")

        if input_dict["use_satellite"]:
            print("Sentinel-2 satellite spectra were combined with the aerial data.")
        else:
            print("Using just the aerial data.")

        if input_dict["scale_by_intensity"]:
            if input_dict["append_intensity"]:
                print("Spectral normalization was employed and the intensity appended as an additional feature.")
            else:
                print("Spectral normalization was employed.")

        if input_dict["robust_scale"]:
            print("RobustScaller() was employed.")
    else:
        print(input_dict["label"])

    plt.rcParams["figure.figsize"] = (12, 10)
    semantic = [text.split(' ', 1)[0] for text in list(config['weights_aerial_satellite'].keys())[:-1]]

    metrics.ConfusionMatrixDisplay.from_predictions(true_classes, predicted_classes, display_labels=semantic,
                                                    normalize='true', xticks_rotation='vertical')

    # Generate a confusion matrix for the random classes
    confusion = metrics.confusion_matrix(true_classes, predicted_classes, normalize='true')
    # row_norm_factors = np.sum(random_confusion, axis=1)[:, np.newaxis]
    # random_confusion = random_confusion / row_norm_factors
    miou, ious = calc_miou(confusion)

    print(f"MIOU is: {miou}")
    np.set_printoptions(precision=4)

    return ious


def box_whisker_by_class(dataframe: pandas.DataFrame, config: dict, channel: int) -> str:
    plt.rcParams["figure.figsize"] = (9, 7)

    # Determine the column label associated with the specified channel.
    channel_column = find_channel_label(dataframe, channel)
    if channel_column.split(' ')[0] == "Error:":
        return channel_column

    # Groupby class, extracting the desired channel
    grouped = dataframe.groupby("True_Class")[[channel_column]].apply(pandas.Series.tolist)

    # Calculate the median, standard deviation, and confidence intervals for each channel
    # class_stds = dataframe.groupby("True_Class")[[channel_column]].std()
    # class_medians = dataframe.groupby("True_Class")[[channel_column]].median()
    # conf_intervals = np.column_stack((class_medians - class_stds, class_medians + class_stds))

    # Extract the semantic class names
    semantic = [text.split(' ', 1)[0] for text in list(config['weights_aerial_satellite'].keys())[:-1]]

    # Determine the colors.
    colors = LUT_COLORS[:len(grouped)]

    # Reverse the order to align the display with other displays
    # grouped = grouped.iloc[::-1]
    semantic.reverse()
    colors.reverse()

    # Display a box-whisker plot
    fig, ax = plt.subplots()
    ax.set_xlabel(f"{channel_column} Values")
    ax.set_ylabel('Semantic Class')
    ax.set_title(f"{channel_column} Channel")
    bplot = ax.boxplot(grouped.iloc[::-1], labels=semantic, vert=False, patch_artist=True)

    for patch, color in zip(bplot['boxes'], colors):
        patch.set_facecolor(color)

    return 'Plotted'


def display_normalization_scatter(dataset, config, channel1=1, channel2=2):
    plt.rcParams["figure.figsize"] = (9, 5)

    original_data = extract_spectra(dataset, config, scale_by_intensity=False)
    normalized_data = extract_spectra(dataset, config, scale_by_intensity=True)

    # Determine the column labels associated with the specified channels.
    channel1_column = find_channel_label(original_data, channel1)
    if channel1_column.split(' ')[0] == "Error:":
        return channel1_column
    channel2_column = find_channel_label(original_data, channel2)
    if channel2_column.split(' ')[0] == "Error:":
        return channel2_column

    plot_kwds = {'alpha': 0.1, 's': 80, 'linewidths': 0}

    plt.subplot(121)
    plt.scatter(original_data[[channel1_column]].to_numpy().ravel(),
                original_data[[channel2_column]].to_numpy().ravel(),
                marker='.', color='b', **plot_kwds)
    plt.xlabel(f"{channel1_column} Channel")
    plt.ylabel(f"{channel2_column} Channel")
    plt.title("Raw Spectra")

    plt.subplot(122)
    plt.scatter(normalized_data[[channel1_column]].to_numpy().ravel(),
                normalized_data[[channel2_column]].to_numpy().ravel(),
                marker='.', color='b', **plot_kwds)
    plt.xlabel(f"{channel1_column} Channel")
    plt.ylabel(f"{channel2_column} Channel")
    plt.title("Normalized Spectra")

    print('Plotted')


def class_distributions(train_dataset, config):
    plt.rcParams["figure.figsize"] = (10, 6)

    # Determine all labels and the count of pixels (labels)
    train_label_list = []
    patch_class_count = []
    for idx in range(len(train_dataset)):
        this_patch = torch.Tensor.numpy(train_dataset[idx]['labels']).ravel()
        train_label_list.append(this_patch)
        patch_class_count.append(np.unique(this_patch).size)
    train_labels = np.concatenate(train_label_list).astype(int)

    classes, counts = np.unique(train_labels, return_counts=True)
    total_counts = np.sum(counts)
    percentiles = (counts * 100) / total_counts
    percentiles = percentiles.tolist()
    percentiles = ["{:.1f}%".format(percentile) for percentile in percentiles]

    print(f"Patches had a minimum of {np.min(patch_class_count).astype(int)} and maximum of {np.max(patch_class_count).astype(int)} classes per patch with an average of {np.mean(patch_class_count):.1f}.")

    bar_colors = LUT_COLORS[:12] + LUT_COLORS[-1:]
    semantic = [text.split(' ', 1)[0] for text in list(config['weights_aerial_satellite'].keys())]

    fig, ax = plt.subplots()
    rects = ax.bar(semantic, counts, color=bar_colors)
    ax.set_xlabel("Classes")
    ax.set_ylabel("Pixels")
    ax.set_title("Training Data Distribution")
    ax.set_xticklabels(semantic, rotation=90)

    ax.bar_label(rects, percentiles, padding=5, color='black', fontweight='bold')

    return train_labels


def plot_timing(times, use_satellite=False):
    np.set_printoptions(precision=1)

    conditions = ["O", "R", "O w/ N", "R w/ N", "O w/ N + I", "R w/ N + I"]

    x = np.arange(len(conditions))  # the label locations
    width = 0.25  # the width of the bars
    multiplier = 0

    keys = list(times.keys())
    max_knn = np.max(np.asarray(times[keys[0]]))
    max_hdbscan = np.max(np.asarray(times[keys[1]]))
    max_val = max(max_knn, max_hdbscan)

    fig, ax = plt.subplots(layout='constrained')

    for attribute, measurement in times.items():
        offset = width * multiplier
        ax.bar(x + offset, measurement, width, label=attribute)
        multiplier += 1

    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_ylabel('Computational Time (minutes)')
    if use_satellite:
        ax.set_title('Fusion Model Time by Algorithm')
        ax.set_yscale('log')
        ax.set_ylim(1, max_val * 2.0)
    else:
        ax.set_title('Aerial Model Time by Algorithm')
        ax.set_ylim(0, max_val * 1.2)
    ax.set_xticks(x + width, conditions, rotation=90)
    ax.legend(loc='upper left', ncols=2)

    plt.show()
