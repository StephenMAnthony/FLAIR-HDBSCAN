import numpy as np
import pandas
import torch
import matplotlib.pyplot as plt
from sklearn import metrics

from calc_miou import calc_miou
from classifier import extract_spectra
from data_display import lut_colors
from data_display import convert_to_color

LUT_COLORS = ['#db0e9a',
              '#938e7b',
              '#f80c00',
              '#a97101',
              '#1553ae',
              '#194a26',
              '#46e483',
              '#f3a60d',
              '#660082',
              '#55ff00',
              '#fff30d',
              '#e4df7c',
              '#3de6eb',
              '#ffffff',
              '#8ab3a0',
              '#6b714f',
              '#c5dc42',
              '#9999ff',
              '#000000']


def find_channel_label(dataframe: pandas.DataFrame, channel: int) -> str:
    # Determine the column label associated with the specified channel.
    columns = dataframe.columns.values.tolist()
    n_columns = len(columns)
    if channel < 1 or channel >= n_columns:
        return f"Error: Channel must be between 1 and {n_columns - 1}!"
    else:
        return columns[channel]


def display_confusion(input_dict: dict, config: dict):
    np.set_printoptions(precision=1)

    true_classes = input_dict["true_classes"]
    predicted_classes = input_dict["predicted_classes"]

    if "model" in input_dict:
        # We have a model. Unpack variables and display a convenient string detailing the model
        if input_dict["use_hdbscan"]:
            print("Using labels autonomously generated by HDBSCAN to fit the KNN model.")
        else:
            print("Using manually annotated labels to fit the KNN model.")

        if input_dict["use_satellite"]:
            print("Sentinel-2 satellite spectra were combined with the aerial data.")
        else:
            print("Using just the aerial data.")

        if input_dict["scale_by_intensity"]:
            if input_dict["append_intensity"]:
                print("Spectral normalization was employed and the intensity appended as an additional feature.")
            else:
                print("Spectral normalization was employed.")

        if input_dict["robust_scale"]:
            print("RobustScaller() was employed.")
    else:
        print(input_dict["label"])

    plt.rcParams["figure.figsize"] = (12, 10)
    semantic = [text.split(' ', 1)[0] for text in list(config['weights_aerial_satellite'].keys())[:-1]]

    metrics.ConfusionMatrixDisplay.from_predictions(true_classes, predicted_classes, display_labels=semantic,
                                                    normalize='true', xticks_rotation='vertical')

    # Generate a confusion matrix for the random classes
    confusion = metrics.confusion_matrix(true_classes, predicted_classes, normalize='true')
    # row_norm_factors = np.sum(random_confusion, axis=1)[:, np.newaxis]
    # random_confusion = random_confusion / row_norm_factors
    miou, ious = calc_miou(confusion)

    print(f"MIOU is: {miou}")
    np.set_printoptions(precision=4)

    return ious


def box_whisker_by_class(dataframe: pandas.DataFrame, config: dict, channel: int) -> str:
    plt.rcParams["figure.figsize"] = (9, 7)

    n_classes = config['num_classes'] - 1

    # Determine the column label associated with the specified channel.
    channel_column = find_channel_label(dataframe, channel)
    if channel_column.split(' ')[0] == "Error:":
        return channel_column

    # Group by class, extracting the desired channel
    grouped = dataframe.groupby("True_Class")[[channel_column]].apply(pandas.Series.tolist)

    # Calculate the median, standard deviation, and confidence intervals for each channel
    # class_stds = dataframe.groupby("True_Class")[[channel_column]].std()
    # class_medians = dataframe.groupby("True_Class")[[channel_column]].median()
    # conf_intervals = np.column_stack((class_medians - class_stds, class_medians + class_stds))

    # Extract the semantic class names
    semantic = [text.split(' ', 1)[0] for text in list(config['weights_aerial_satellite'].keys())[:-1]]

    # Determine the colors.
    colors = LUT_COLORS[:n_classes]

    # Reverse the order to align the display with other displays
    # grouped = grouped.iloc[::-1]
    semantic.reverse()
    colors.reverse()

    # Determine the classes that are present and reduce to those
    classes_present = np.unique(dataframe.loc[:, "True_Class"].values.astype(int)).tolist()
    semantic = [semantic[idx] for idx in classes_present]
    colors = [colors[idx] for idx in classes_present]

    # Display a box-whisker plot
    fig, ax = plt.subplots()
    ax.set_xlabel(f"{channel_column} Values")
    ax.set_ylabel('Semantic Class')
    ax.set_title(f"{channel_column} Channel")
    bplot = ax.boxplot(grouped.iloc[::-1], labels=semantic, vert=False, patch_artist=True)

    for patch, color in zip(bplot['boxes'], colors):
        patch.set_facecolor(color)

    return 'Plotted'


def display_normalization_scatter(dataset, config, channel1=1, channel2=2):
    plt.rcParams["figure.figsize"] = (9, 5)

    original_data = extract_spectra(dataset, config, scale_by_intensity=False)
    normalized_data = extract_spectra(dataset, config, scale_by_intensity=True)

    # Determine the column labels associated with the specified channels.
    channel1_column = find_channel_label(original_data, channel1)
    if channel1_column.split(' ')[0] == "Error:":
        return channel1_column
    channel2_column = find_channel_label(original_data, channel2)
    if channel2_column.split(' ')[0] == "Error:":
        return channel2_column

    plot_kwds = {'alpha': 0.1, 's': 80, 'linewidths': 0}

    plt.subplot(121)
    plt.scatter(original_data[[channel1_column]].to_numpy().ravel(),
                original_data[[channel2_column]].to_numpy().ravel(),
                marker='.', color='b', **plot_kwds)
    plt.xlabel(f"{channel1_column} Channel")
    plt.ylabel(f"{channel2_column} Channel")
    plt.title("Raw Spectra")

    plt.subplot(122)
    plt.scatter(normalized_data[[channel1_column]].to_numpy().ravel(),
                normalized_data[[channel2_column]].to_numpy().ravel(),
                marker='.', color='b', **plot_kwds)
    plt.xlabel(f"{channel1_column} Channel")
    plt.ylabel(f"{channel2_column} Channel")
    plt.title("Normalized Spectra")

    print('Plotted')


def class_distributions(train_dataset, config):
    plt.rcParams["figure.figsize"] = (10, 6)

    n_classes = config['num_classes']

    # Determine all labels and the count of pixels (labels)
    train_label_list = []
    patch_class_count = []
    for idx in range(len(train_dataset)):
        this_patch = torch.Tensor.numpy(train_dataset[idx]['labels']).ravel()
        train_label_list.append(this_patch)
        patch_class_count.append(np.unique(this_patch).size)
    train_labels = np.concatenate(train_label_list).astype(int)

    unique_classes, unique_counts = np.unique(train_labels, return_counts=True)

    # Ensure all classes are represented, assigning 0 counts to missing classes.
    classes = np.arange(n_classes)
    counts = np.zeros_like(classes)
    counts[unique_classes] = unique_counts

    total_counts = np.sum(counts)
    percentiles = (counts * 100) / total_counts
    percentiles = percentiles.tolist()
    percentiles = ["{:.1f}%".format(percentile) for percentile in percentiles]

    print(f"Patches had a minimum of {np.min(patch_class_count).astype(int)} and maximum of {np.max(patch_class_count).astype(int)} classes per patch with an average of {np.mean(patch_class_count):.1f}.")

    bar_colors = LUT_COLORS[:n_classes] + LUT_COLORS[-1:]
    semantic = [text.split(' ', 1)[0] for text in list(config['weights_aerial_satellite'].keys())]

    fig, ax = plt.subplots()
    rects = ax.bar(semantic, counts, color=bar_colors)
    ax.set_xlabel("Classes")
    ax.set_ylabel("Pixels")
    ax.set_title("Data Distribution")
    ax.set_xticklabels(semantic, rotation=90)

    ax.bar_label(rects, percentiles, padding=5, color='black', fontweight='bold')

    return train_labels


def plot_timing(times, use_satellite=False):
    np.set_printoptions(precision=1)

    conditions = ["O", "R", "O w/ N", "R w/ N", "O w/ N + I", "R w/ N + I"]

    x = np.arange(len(conditions))  # the label locations
    width = 0.25  # the width of the bars
    multiplier = 0

    keys = list(times.keys())
    max_knn = np.max(np.asarray(times[keys[0]]))
    max_hdbscan = np.max(np.asarray(times[keys[1]]))
    max_val = max(max_knn, max_hdbscan)

    fig, ax = plt.subplots(layout='constrained')

    for attribute, measurement in times.items():
        offset = width * multiplier
        ax.bar(x + offset, measurement, width, label=attribute)
        multiplier += 1

    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_ylabel('Computational Time (minutes)')
    if use_satellite:
        ax.set_title('Fusion Model Time by Algorithm')
        ax.set_yscale('log')
        ax.set_ylim(1, max_val * 2.0)
    else:
        ax.set_title('Aerial Model Time by Algorithm')
        ax.set_ylim(0, max_val * 1.2)
    ax.set_xticks(x + width, conditions, rotation=90)
    ax.legend(loc='upper left', ncols=2)

    plt.show()


def compare_labels(the_dataset, knn, hdbscan, config, index=0):
    n_classes = config['num_classes'] - 1
    aerial_side = config['aerial_side']

    # Load the aerial data and the labels
    aerial = torch.Tensor.numpy(the_dataset[index]['aerial'])
    true_labels = torch.Tensor.numpy(the_dataset[index]['labels'])

    aerial = np.transpose(aerial, [1, 2, 0])
    true_labels = true_labels + 1

    n_prior_nonother_labels = 0
    current_count = 0
    for idx in range(index + 1):
        # Update the count of the total number of non-other labels for prior indices
        n_prior_nonother_labels += current_count

        # Load the labels
        labels = torch.Tensor.numpy(the_dataset[idx]['labels'])
        labels = labels.ravel()
        keep = labels < n_classes
        current_count = np.count_nonzero(keep)

    # Load the knn and hdbscan labels
    knn_labels = knn['predicted_classes']
    hdbscan_labels = hdbscan['predicted_classes']

    # Reduce the predicted labels to only the relevant portion
    knn_labels = knn_labels[n_prior_nonother_labels:(n_prior_nonother_labels + current_count)] + 1
    hdbscan_labels = hdbscan_labels[n_prior_nonother_labels:(n_prior_nonother_labels + current_count)] + 1

    # Create default label images with all pixels set to the other class.
    knn_image = np.full((aerial_side, aerial_side), 19)
    hdbscan_image = np.full((aerial_side, aerial_side), 19)

    # Add the labels in the appropriate positions
    knn_image.ravel()[keep] = knn_labels
    hdbscan_image.ravel()[keep] = hdbscan_labels

    # Convert to color
    colored_true = convert_to_color(true_labels, palette=lut_colors)
    colored_knn = convert_to_color(knn_image, palette=lut_colors)
    colored_hdbscan = convert_to_color(hdbscan_image, palette=lut_colors)

    # Now, mask off areas where the predicted and true values agree
    knn_image[knn_image == true_labels] = 19
    hdbscan_image[hdbscan_image == true_labels] = 19

    incorrect_knn = convert_to_color(knn_image, palette=lut_colors)
    incorrect_hdbscan = convert_to_color(hdbscan_image, palette=lut_colors)

    fig, axs = plt.subplots(nrows=3, ncols=3, figsize=(10, 10))
    fig.subplots_adjust(wspace=0.0, hspace=0.15)
    fig.patch.set_facecolor('black')

    ax0 = axs[0][0]
    ax0.imshow(aerial[:, :, :3])
    ax0.axis('off')
    ax0.set_title('RGB Image', size=12, fontweight="bold", c='w')

    ax1 = axs[0][1]
    ax1.imshow(colored_true, interpolation='nearest')
    ax1.axis('off')
    ax1.set_title('Annotated Classes', size=12, fontweight="bold", c='w')

    ax2 = axs[0][2]
    ax2.imshow(aerial[:, :, :3])
    ax2.imshow(colored_true, interpolation='nearest', alpha=0.25)
    ax2.axis('off')
    ax2.set_title('Overlay Image & Manual', size=12, fontweight="bold", c='w')

    ax3 = axs[1][0]
    ax3.imshow(incorrect_knn)
    ax3.axis('off')
    ax3.set_title('Incorrect KNN', size=12, fontweight="bold", c='w')

    ax4 = axs[1][1]
    ax4.imshow(colored_knn, interpolation='nearest')
    ax4.axis('off')
    ax4.set_title('KNN Predictions', size=12, fontweight="bold", c='w')

    ax5 = axs[1][2]
    ax5.imshow(aerial[:, :, :3])
    ax5.imshow(colored_knn, interpolation='nearest', alpha=0.25)
    ax5.axis('off')
    ax5.set_title('Overlay Image & KNN', size=12, fontweight="bold", c='w')

    ax6 = axs[2][0]
    ax6.imshow(incorrect_hdbscan)
    ax6.axis('off')
    ax6.set_title('Incorrect HDBSCAN', size=12, fontweight="bold", c='w')

    ax7 = axs[2][1]
    ax7.imshow(colored_hdbscan, interpolation='nearest')
    ax7.axis('off')
    ax7.set_title('HDBSCAN Predictions', size=12, fontweight="bold", c='w')

    ax8 = axs[2][2]
    ax8.imshow(aerial[:, :, :3])
    ax8.imshow(colored_hdbscan, interpolation='nearest', alpha=0.25)
    ax8.axis('off')
    ax8.set_title('Overlay Image & HDBSCAN', size=12, fontweight="bold", c='w')


def display_pixel_spectrum(the_dataframe, config, patch_index=0, row_index=0, column_index=0):
    aerial_side = config['aerial_side']

    patch_offset = aerial_side * aerial_side * patch_index
    column_offset = aerial_side * column_index
    row_offset = row_index
    total_offset = patch_offset + column_offset + row_offset

    # Get the column names
    column_names = the_dataframe.columns.tolist()

    label = the_dataframe.iloc[total_offset, 0]
    label_name = column_names[0]

    aerial = the_dataframe.iloc[total_offset, 1:5]
    aerial_names = column_names[1:5]

    satellite = the_dataframe.iloc[total_offset, 5:15]
    satellite_names = column_names[5:15]

    elevation = the_dataframe.iloc[total_offset, 15]
    elevation_name = column_names[15]

    fig, axs = plt.subplots(nrows=1, ncols=2, figsize=(9, 6))

    print(
        f"Pixel from patch {patch_index}, row {row_index}, and column {column_index} belongs to {label_name} {label} and has {elevation_name} of {elevation}.")

    ax0 = axs[0]
    ax0.plot(np.linspace(0, 3, 4), aerial)
    ax0.set_xticks(np.arange(0, 4, 1))
    ax0.set_xticklabels(aerial_names, rotation=0)
    ax0.set_title('Aerial Spectra', size=12, fontweight="bold", c='k')
    ax0.set_xlabel("Channel")
    ax0.set_ylabel("Intensity")
    ax0.set(xlim=(0, 3), xticks=np.arange(0, 4, 1), ylim=(0, 1), yticks=np.arange(0, 1.1, 0.1))

    ax1 = axs[1]
    ax1.plot(np.arange(0, 10, 1), satellite)
    ax1.set_xticks(np.arange(0, 10, 1))
    ax1.set_xticklabels(satellite_names, rotation=0)
    ax1.set_title('Satellite Spectra', size=12, fontweight="bold", c='k')
    ax1.set_xlabel("Band")
    ax1.set_ylabel("Intensity")
    ax1.set(xlim=(0, 9), ylim=(0, 1), yticks=np.arange(0, 1.1, 0.1))

    return the_dataframe.iloc[total_offset:(total_offset + 1)]


def dict_to_dataframe(input_dict):
    # Calculate the intensity
    input_dict['Aerial Intensity'] = [input_dict['Blue'][0] + input_dict['Green'][0] + input_dict['Red'][0]]
    manual_df = pandas.DataFrame.from_dict(input_dict)
    return manual_df
